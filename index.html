<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WDT4vRO</title>
  <link rel="stylesheet" href="https://unpkg.com/@clr/ui/clr-ui.min.css" />
  <link rel="stylesheet" href="https://unpkg.com/@clr/icons/clr-icons.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
  <script src="https://unpkg.com/svg2pdf.js@2.3.4/dist/svg2pdf.min.js"></script>
  <style>
    /* Smooth scrolling for anchor links */
    html {
      scroll-behavior: smooth;
    }
    
    /* Style for workflow item sections */
    .workflow-item {
      scroll-margin-top: 80px; /* Space for fixed header */
      transition: all 0.3s ease;
    }
    
    .workflow-item {
      transform: translateZ(0); /* Force hardware acceleration */
      backface-visibility: hidden;
      perspective: 1000px;
      will-change: background-color, box-shadow, padding, margin;
    }
    
    .workflow-item:target {
      animation: highlightFade 1.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    
    @keyframes highlightFade {
      0% {
        background-color: rgba(0, 124, 187, 0.3);
        box-shadow: 0 0 0 4px rgba(0, 124, 187, 0.3);
        border-radius: 4px;
        padding: 10px;
        margin: -10px;
      }
      30% {
        background-color: rgba(0, 124, 187, 0.2);
        box-shadow: 0 0 0 3px rgba(0, 124, 187, 0.2);
      }
      60% {
        background-color: rgba(0, 124, 187, 0.1);
        box-shadow: 0 0 0 2px rgba(0, 124, 187, 0.1);
      }
      100% {
        background-color: transparent;
        box-shadow: 0 0 0 0 transparent;
        border-radius: 0;
        padding: 0;
        margin: 0;
      }
    }
    
    @import url('https://fonts.googleapis.com/css2?family=Metropolis:wght@400;700&display=swap');
    body {
      font-family: 'Metropolis', Arial, sans-serif;
      font-size: 14px;
      background-color: #f7fafd;
      margin: 0;
      padding: 0;
    }

    h1 {
      font-family: 'Metropolis', Arial, sans-serif;
      color: #007cbb;
      text-align: center;
      margin-top: 20px;
      font-size: 24px;
    }

    .upload-section {
      font-family: 'Metropolis', Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 20px;
      font-size: 14px;
      gap: 10px;
    }

    #graph {
      border: 1px solid #ccc;
      margin: 20px auto;
      background-color: #ffffff;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 20px;
      max-width: 90%;
      text-align: center;
      overflow: auto;
    }

    .details {
      font-family: 'Metropolis', Arial, sans-serif;
      margin: 20px auto;
      max-width: 90%;
      background-color: #ffffff;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      padding: 20px;
      font-size: 14px;
      word-wrap: break-word;
      overflow-wrap: break-word;
    }

    .details h2 {
      margin-bottom: 20px;
    }

    .details h4 {
      font-weight: bold;
      margin-bottom: 20px;
    }

    .details table {
      /* margin-top: 10px; */
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      table-layout: fixed;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      table-layout: fixed;
    }

    th, td {
      font-family: 'Metropolis', Arial, sans-serif;
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: normal;
      max-width: 200px;
    }

    th {
      font-family: 'Metropolis', Arial, sans-serif;
      background-color: #007cbb;
      color: #ffffff;
    }

    pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: #f8f8f8;
      padding: 10px;
      border-radius: 4px;
    }
    
    button {
      padding: 8px 16px;
      background-color: #007cbb;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: 'Metropolis', Arial, sans-serif;
    }
    
    button:hover {
      background-color: #0069a3;
    }

    .error {
      color: red;
      background-color: #ffe6e6;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }

    .success {
      color: green;
      background-color: #e6ffe6;
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }

    .top-bar {
      background: #0d233a;
      border-bottom: 1px solid #0d233a;
      padding: 16px 32px;
      display: flex;
      align-items: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.03);
      margin-bottom: 0;
    }
    .top-bar .icon {
      width: 32px;
      height: 32px;
      margin-right: 16px;
      display: inline-block;
      vertical-align: middle;
    }
    .top-bar .title {
      font-family: 'Metropolis', Arial, sans-serif;
      font-size: 1rem;
      font-weight: 200;
      color: #fff;
      letter-spacing: 0.5px;
      text-align: left;
      display: inline-block;
      vertical-align: middle;
      cursor: pointer;
    }
    .themed-input[type="file"] {
      display: none;
    }
    .welcome-box, .welcome-notes, .welcome-box ul, .welcome-box li {
      font-family: 'Metropolis', Arial, sans-serif;
    }
    .btn {
      font-family: 'Metropolis', Arial, sans-serif;
      font-size: 14px;
      font-weight: 600;
      border-radius: 6px;
      padding: 12px 24px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
    }
    
    .btn.btn-primary {
      background: #007cbb !important;
      color: #fff !important;
      border: none !important;
      box-shadow: 0 2px 8px rgba(0,124,187,0.15);
    }
    .btn.btn-primary:hover {
      background: #0069a3 !important;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,124,187,0.2);
    }
    
    .btn.btn-outline {
      background: transparent;
      border: 1px solid #007cbb;
      color: #007cbb;
    }
    
    .btn.btn-outline:hover {
      background: rgba(0, 124, 187, 0.05);
      transform: translateY(-1px);
    }
    
    .github-link {
      opacity: 0.9;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    
    .github-link:hover {
      opacity: 1;
      transform: translateY(-1px);
      color: #fff !important;
    }
    .welcome-box {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.1);
      max-width: 1400px;
      width: calc(100% - 40px);
      margin: 12px auto;
      display: flex;
      flex-wrap: wrap;
      padding: 1.2rem 1.5rem;
      gap: 1.2rem;
      box-sizing: border-box;
    }
    .welcome-notes {
      flex: 1 1 300px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: flex-start;
      text-align: left;
      min-width: 0;
      padding: 1.5rem 1.8rem 2rem 1.8rem;
      overflow: hidden;
      width: 100%;
      box-sizing: border-box;
    }
    .welcome-notes h2 {
      font-size: clamp(1.1rem, 2.4vw, 1.4rem);
      font-weight: 600;
      margin: 0 0 1.2rem 0;
      color: #1f2328;
      width: 100%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .welcome-notes .welcome-desc {
      font-size: clamp(0.7rem, 1.2vw, 0.8rem);
      line-height: 1.5;
      margin: 0 0 0.8rem 0;
      color: #4a5568;
    }
    .welcome-notes ul {
      font-size: clamp(0.65rem, 1.1vw, 0.75rem);
      margin: 0 0 1rem 0;
      padding-left: 1rem;
      line-height: 1.6;
      color: #4a5568;
    }
    .welcome-graphic {
      flex: 1 1 300px;
      min-height: 280px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
      padding: 1rem;
    }
    .dot-bg {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      background-image: radial-gradient(#e0e4ea 1.5px, transparent 1.5px);
      background-size: 18px 18px;
      background-position: 0 0;
    }
    .welcome-graphic img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      position: relative;
      z-index: 1;
    }
    .welcome-upload-bottom {
      width: 100%;
      margin-top: 1.2rem;
      z-index: 2;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      position: relative;
      left: 0;
      bottom: 0;
      padding-top: 1rem;
      border-top: 1px solid #eaeef2;
    }
    .upload-section {
      margin-top: 16px;
      display: flex;
      justify-content: flex-start;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      width: 100%;
    }
    
    .upload-section .btn {
      margin: 0;
      white-space: nowrap;
    }
    .no-script {
      padding: 10px;
      color: #666;
      font-style: italic;
      border: 1px dashed #ccc;
      text-align: center;
    }

    .footer-note {
      width: 100%;
      text-align: center;
      font-size: 0.85rem;
      color: #888;
      margin-top: 32px;
      margin-bottom: 12px;
      letter-spacing: 0.02em;
      font-family: 'Metropolis', Arial, sans-serif;
    }
    .footer-note a {
      color: #007cbb;
      text-decoration: none;
      font-size: 0.85rem;
      margin-left: 0.2em;
    }
    #messages {
      /* Add font family for all messages */
      font-family: 'Metropolis', Arial, sans-serif;
    }
    #messages > div {
      font-family: 'Metropolis', Arial, sans-serif;
    }
    .details-main-heading {
      font-size: 2.2rem;
      font-weight: 900;
      margin-bottom: 32px;
      margin-top: 0;
      letter-spacing: 0.01em;
    }
    .details-section-heading {
      font-size: 1.25rem;
      font-weight: 700;
      margin-top: 32px;
      margin-bottom: 18px;
      letter-spacing: 0.01em;
    }
    
    @media (max-width: 768px) {
      .welcome-box {
        padding: 1.2rem;
        margin: 8px;
        width: calc(100% - 16px);
      }
      
      .welcome-notes h2 {
        font-size: 1.3rem;
        margin-bottom: 0.5rem;
      }
      
      .welcome-notes .welcome-desc,
      .welcome-notes ul {
        font-size: 0.85rem;
        line-height: 1.5;
      }
      
      .welcome-upload-bottom {
        margin-top: 1.2rem;
        padding-top: 1rem;
      }
      
      .upload-section {
        flex-direction: column;
        gap: 10px;
        width: 100%;
        margin-top: 12px;
      }
      
      .upload-section .btn {
        width: 100%;
        padding: 12px 16px;
        margin: 0;
        font-size: 14px;
      }
      
      .btn.btn-outline {
        margin-top: 0;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs/loader.js"></script>
  <script src="https://unpkg.com/@clr/icons/clr-icons.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
  <div class="top-bar">
    <img src="assets/wdt4vro_icon.svg" class="icon" alt="Workflow Icon" />
    <span class="title" id="mainTitle">Workflow Documentation Tool for VCF Operations Orchestrator™</span>
    <div id="topBarActions" style="margin-left:auto; display:flex; align-items:center; gap: 12px;">
      <a href="https://github.com/imtrinity94/WDT4vRO" target="_blank" rel="noopener noreferrer" class="btn btn-sm btn-outline" style="color: #fff; border-color: rgba(255,255,255,0.6); height: 32px; display: inline-flex; align-items: center; padding: 0 12px; font-size: 13px; font-weight: 500; transition: all 0.2s; margin-right: 8px;" title="View on GitHub">
        <svg height="16" viewBox="0 0 16 16" width="16" fill="currentColor" style="margin-right: 6px;">
          <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
        <span>GitHub</span>
      </a>
      <a href="https://cloudblogger.co.in" target="_blank" rel="noopener noreferrer" class="btn btn-sm btn-outline" style="color: #fff; border-color: rgba(255,255,255,0.6); height: 32px; display: inline-flex; align-items: center; padding: 0 12px; font-size: 13px; font-weight: 500; transition: all 0.2s;" title="View Documentation">
        <svg height="16" viewBox="0 0 24 24" width="16" fill="currentColor" style="margin-right: 6px;">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path>
        </svg>
        <span>Documentation</span>
      </a>
      <a href="https://github.com/imtrinity94/WDT4vRO/issues/new" target="_blank" rel="noopener noreferrer" class="btn btn-sm btn-outline open-issue-btn" style="color: #fff; border-color: rgba(255,255,255,0.6); height: 32px; display: inline-flex; align-items: center; padding: 0 12px; font-size: 13px; font-weight: 500; transition: all 0.2s;" title="Open an issue">
        <svg height="16" viewBox="0 0 16 16" width="16" fill="currentColor" style="margin-right: 6px;">
          <path fill-rule="evenodd" d="M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm9 3a1 1 0 11-2 0 1 1 0 012 0zm-.25-6.25a.75.75 0 00-1.5 0v3.5a.75.75 0 001.5 0v-3.5z"></path>
        </svg>
        <span>Open Issue</span>
      </a>
      <span id="zoomControls" style="display:none; margin-right: 12px;">
        <button id="zoomInBtn" class="btn btn-primary" style="padding: 6px 10px; margin-right: 4px; min-width: 0; width: 36px; height: 36px; display: inline-flex; align-items: center; justify-content: center;">
          <span style="font-size: 20px; color: #fff;">&#x2b;</span> <!-- Plus sign for zoom in -->
        </button>
        <button id="zoomOutBtn" class="btn btn-primary" style="padding: 6px 10px; min-width: 0; width: 36px; height: 36px; display: inline-flex; align-items: center; justify-content: center;">
          <span style="font-size: 20px; color: #fff;">&#x2212;</span> <!-- Minus sign for zoom out -->
        </button>
      </span>
      <button id="downloadSvgBtn" class="btn btn-primary" style="display:none; margin-left: 8px;">Download Diagram</button>
      <button id="downloadHtmlBtn" class="btn btn-primary" style="display:none; margin-left: 8px;">Download as HTML</button>
    </div>
  </div>
  <div class="welcome-box">
    <div class="welcome-notes">
      <h2>👋 Welcome to WDT4vRO v2.0.0</h2>
      <p class="welcome-desc">This tool helps you visualize, document, and understand Orchestrator workflows with clarity. Upload your Orchestrator workflow XML and instantly see a diagram that matches the real Orchestrator Workflow designer, complete with icons, arrows, and details for every node.</p>
      <ul>
        <li>Converts Workflow XMLs into beautiful SVG diagrams</li>
        <li>Lists all the items and their properties</li>
        <li>Monaco-powered code viewer for scripts</li>
        <li>Download PNGs and HTMLs for quick sharing</li>
      </ul>
      <p class="welcome-desc"><strong>What's New in v2.0.0:</strong> Enhanced script display, improved workflow item handling, new branding and better support for custom conditions.</p>
      <div class="welcome-actions" style="margin-top: 1.5rem; display: flex; flex-wrap: wrap; gap: 1rem; width: 100%;">
        <label for="fileUpload" class="btn btn-primary" style="margin: 0;">
          Upload Workflow XML
        </label>
        <button id="helpBtn" class="btn btn-outline" style="margin: 0;">
          <clr-icon shape="help" style="margin-right: 6px;"></clr-icon>How to get workflow XML?
        </button>
      </div>
    </div>
    <div class="welcome-graphic">
      <!-- <div class="dot-bg"></div> -->
      <img src="assets/welcome-note-image.png" alt="Workflow Graphic" />
    </div>
    <input type="file" id="fileUpload" accept=".xml" class="themed-input" style="display: none;">
  </div>
  <div id="messages"></div>
  <div id="exportArea">
    <div id="graphZoomContainer" style="display:none; width: 100%; height: 100%; overflow: auto;">
      <!-- <div class="dot-bg" style="position: relative;"> -->
        <div id="graph" style="position: relative; z-index: 1;"></div>
    </div>
    <div class="details" style="display:none;">
    <div id="details"></div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="helpModal" style="display: none; font-family: 'Metropolis', Arial, sans-serif; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
    <div style="background: white; padding: 2rem; border-radius: 8px; max-width: 700px; width: 90%; max-height: 80vh; overflow-y: auto; position: relative;">
      <button id="closeHelp" style="position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 1.5rem; cursor: pointer;">&times;</button>
      <h2 style="margin-top: 0; color: #007cbb;">How to Get Workflow XML</h2>
      
      <div style="margin: 1.5rem 0;">
        <h3 style="color: #007cbb;">Method 1: From Orchestrator Package</h3>
        <ol style="margin-top: 0.5rem; padding-left: 1.2rem;">
          <li>In Orchestrator, Add your workflow to a package</li>
          <li><strong>Export</strong> the .package file to your computer</li>
          <li>Rename the file extension from .package to .zip</li>
          <li>Extract the ZIP file</li>
          <li>Navigate to the workflow's folder inside the extracted contents</li>
          <li>Go to elements folder and open folder named like 66b864a7-c7d9-4807-803a-a08cb6499b70</li>
          <li>Look for a file named <strong>data</strong> (no extension) inside this folder</li>
          <li>Rename this file to <strong>workflow.xml</strong></li>
          <li>Upload the file using the "Upload Workflow XML" button</li>
        </ol>
      </div>
      
      <div style="margin: 1.5rem 0;">
        <h3 style="color: #007cbb;">Method 2: From GitHub Repository</h3>
        <ol style="margin-top: 0.5rem; padding-left: 1.2rem;">
          <li>Navigate to your GitHub repository containing Orchestrator workflows</li>
          <li>Go to Workflow directories</li>
          <li>Look for files named <strong>workflow.xml</strong> inside any folder named as workflow name</li>
          <li>Click on the file to view it</li>
          <li>Click the <strong>Raw</strong> button to view the raw XML</li>
          <li>Right-click and select <strong>Save As...</strong> to save the file</li>
          <li>Upload the saved file using the "Upload Workflow XML" button</li>
        </ol>
      </div>
      
      <div style="margin-top: 2rem; font-size: 0.9em; color: #666; border-top: 1px solid #eee; padding-top: 1rem;">
        <p>Note: Make sure the XML file follows the standard Orchestrator workflow XML format for proper parsing.</p>
      </div>
    </div>
  </div>

  <!-- <footer class="footer-note">
    Developed by Mayank Goyal (mayankgoyalmax@gmail.com) &bull; Website <a href="https://cloudblogger.co.in" target="https://cloudblogger.co.in" style="color: #007cbb;">https://cloudblogger.co.in</a>
  </footer> -->

  <!-- Floating Buttons Container -->
  <div id="floatingButtons" style="position: fixed; right: 30px; bottom: 30px; display: flex; flex-direction: column; gap: 12px; z-index: 99;">
    <!-- Go to Top Button -->
    <button id="goToTopBtn" title="Go to top" style="
      display: none !important;
      border: none;
      outline: none;
      background-color: #007cbb;
      color: white;
      cursor: pointer;
      padding: 0;
      border-radius: 50%;
      font-size: 24px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.8;
      font-weight: bold;
      line-height: 1;
    ">
      ↑
    </button>

    <!-- Home Button -->
    <button id="homeBtn" title="Return to Home" style="
      display: none;
      border: none;
      outline: none;
      background-color: #007cbb;
      color: white;
      cursor: pointer;
      padding: 0;
      border-radius: 50%;
      font-size: 24px;
      transition: all 0.3s ease;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      width: 50px;
      height: 50px;
      align-items: center;
      justify-content: center;
      opacity: 0.8;
      font-weight: bold;
    ">
      🏠
    </button>
  </div>

  <!-- Progress bar container -->
  <div id="progressContainer" class="progress-block" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 0 20px rgba(0,0,0,0.2); z-index: 1000; max-width: 90%; width: 400px; text-align: center;">
    <h3 style="font-family: 'Metropolis', Arial, sans-serif;">Generating HTML File</h3>
    <div class="progress">
      <progress value="0" max="100" class="progress-bar" style="width: 100%;"></progress>
    </div>
    <div class="progress-status" style="margin-top: 1rem; font-size: 0.9rem; font-family: 'Metropolis', Arial, sans-serif; color: #666;">Preparing download...</div>
  </div>
  <div id="overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;"></div>

  <script>
    // Help modal functionality
    document.addEventListener('DOMContentLoaded', function() {
      const helpBtn = document.getElementById('helpBtn');
      const helpModal = document.getElementById('helpModal');
      const closeHelp = document.getElementById('closeHelp');
      
      if (helpBtn && helpModal) {
        helpBtn.addEventListener('click', function() {
          helpModal.style.display = 'flex';
        });
      }
      
      if (closeHelp) {
        closeHelp.addEventListener('click', function() {
          helpModal.style.display = 'none';
        });
      }
      
      // Close modal when clicking outside the content
      window.addEventListener('click', function(event) {
        if (event.target === helpModal) {
          helpModal.style.display = 'none';
        }
      });
    });

    // Floating buttons functionality
    document.addEventListener('DOMContentLoaded', function() {
      const goToTopBtn = document.getElementById('goToTopBtn');
      const homeBtn = document.getElementById('homeBtn');
      let isWorkflowLoaded = false;

      // Function to show/hide workflow-related UI elements
      window.toggleWorkflowUI = function(show) {
        isWorkflowLoaded = show;
        
        // Show/hide the home button (always visible when workflow is loaded)
        if (homeBtn) {
          homeBtn.style.display = show ? 'flex' : 'none';
        }
        
        // Show/hide GitHub, Documentation, and Open Issue buttons
        const githubLink = document.querySelector('a[href*="github.com"]:not(.open-issue-btn)');
        const docBtn = document.querySelector('a[href*="cloudblogger"]');
        const openIssueBtn = document.querySelector('.open-issue-btn');
        
        if (githubLink) {
          githubLink.style.display = show ? 'none' : 'inline-flex';
        }
        if (docBtn) {
          docBtn.style.display = show ? 'none' : 'inline-flex';
        }
        if (openIssueBtn) {
          openIssueBtn.style.display = show ? 'none' : 'inline-flex';
        }
        
        // Show/hide the go-to-top button based on scroll position
        if (goToTopBtn) {
          if (show) {
            window.onscroll(); // Trigger scroll handler to update button state
          } else {
            goToTopBtn.style.display = 'none';
          }
        }
      };
      
      // Show/hide button on scroll (only if workflow is loaded)
      window.onscroll = function() {
        if (!isWorkflowLoaded) {
          if (goToTopBtn) goToTopBtn.style.display = 'none';
          return;
        }
        
        if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
          if (goToTopBtn) {
            goToTopBtn.style.display = 'flex';
            goToTopBtn.style.opacity = '1';
          }
        } else {
          if (goToTopBtn) {
            goToTopBtn.style.opacity = '0.8';
          }
        }
      };
      
      // Scroll to top when button is clicked
      if (goToTopBtn) {
        goToTopBtn.addEventListener('click', function() {
          window.scrollTo({
            top: 0,
            behavior: 'smooth'
          });
        });
      }
      
      // Handle home button click
      if (homeBtn) {
        homeBtn.addEventListener('click', function() {
          // Show welcome screen and hide workflow view
          document.querySelector('.welcome-box').style.display = '';
          document.getElementById('graphZoomContainer').style.display = 'none';
          document.querySelector('.details').style.display = 'none';
          
          // Hide download buttons when returning to welcome screen
          const downloadButtons = ['downloadSvgBtn', 'downloadHtmlBtn'];
          downloadButtons.forEach(btnId => {
            const btn = document.getElementById(btnId);
            if (btn) btn.style.display = 'none';
          });
          
          // Hide zoom controls when returning to welcome screen
          const zoomControls = document.getElementById('zoomControls');
          if (zoomControls) zoomControls.style.display = 'none';
          
          // Hide floating buttons
          window.toggleWorkflowUI(false);
          
          // Reset file input
          const fileInput = document.getElementById('fileUpload');
          if (fileInput) fileInput.value = '';
        });
      }
    });

    // Icon mapping for different workflow item types and prototype-ids
    const iconMapping = {
      "end": "icons/end.svg",
      "scriptable-task": "icons/scriptable-task.svg",
      "condition": "icons/condition.svg",
      "custom-condition": "icons/condition.svg",
      "input": "icons/input.svg",
      "waiting-timer": "icons/waiting-timer.svg",
      "waiting-event": "icons/waiting-event.svg",
      "action": "icons/action.svg",
      "workflow": "icons/workflow.svg",
      "foreach": "icons/foreach.svg",
      "multiple": "icons/multiple.svg",
      "decision-activity": "icons/decision-activity.svg",
      "switch": "icons/switch.svg",
      "task:prototype-id=change-credential": "icons/change-credential.svg",
      "task:prototype-id=sleep": "icons/sleep.svg",
      "task:prototype-id=wait-until-date": "icons/wait-until-date.svg",
      "task:prototype-id=wait-custom-event": "icons/wait-custom-event.svg",
      "task:prototype-id=send-custom-event": "icons/send-custom-event.svg",
      "task:prototype-id=increase-counter": "icons/increase-counter.svg",
      "task:prototype-id=decrease-counter": "icons/decrease-counter.svg",
      "task:prototype-id=system-log": "icons/system-log.svg",
      "task:prototype-id=system-warning": "icons/system-warning.svg",
      "task:prototype-id=system-error": "icons/system-error.svg",
      "task:prototype-id=server-log": "icons/server-log.svg",
      "task:prototype-id=server-warning": "icons/server-warning.svg",
      "task:prototype-id=server-error": "icons/server-error.svg",
      "task:prototype-id=system-server-log": "icons/system-server-log.svg",
      "task:prototype-id=system-server-warning": "icons/system-server-warning.svg",
      "task:prototype-id=system-server-error": "icons/system-server-error.svg",
      "task:prototype-id=http-post": "icons/http-post.svg",
      "task:prototype-id=http-get": "icons/http-get.svg",
      "start": "icons/start.svg",
      "default": "icons/workflow.svg"
    };

    // Color mapping for different node types
    const colorMapping = {
      "task": "#4CAF50",
      "scriptable-task": "#4CAF50",
      "action": "#4CAF50", 
      "condition": "#FF9800",
      "decision": "#FF9800",
      "end": "#F44336",
      "start": "#2196F3",
      "workflow": "#2196F3",
      "default": "#9E9E9E"
    };

    // Helper to get icon for a node
    function getIconForNode(item) {
      const itemName = item.getAttribute("name");
      console.log('getIconForNode called for item:', itemName, 'node type:', item.nodeName);
      
      const type = item.getAttribute("type");
      const prototypeId = item.getAttribute("prototype-id");
      const scriptModule = item.getAttribute("script-module");
      
      console.log('Item attributes:', {
        name: itemName,
        type: type,
        prototypeId: prototypeId,
        scriptModule: scriptModule
      });
      
      // Special case: End node with end-mode="1" should use exception icon
      if (type === "end" && item.getAttribute("end-mode") === "1") {
        return "icons/exception.svg";
      }

      // Special case: Async workflow task
      if (type === "task") {
        // Check for async workflow conditions:
        // 1. Must have launched-workflow-id attribute (can be empty)
        // 2. Must have out-binding with type="WorkflowToken" and name="wfToken"
        const hasLaunchedWorkflowId = item.hasAttribute("launched-workflow-id");
        const outBinds = item.getElementsByTagName("out-binding")[0]?.getElementsByTagName("bind") || [];
        
        const hasCorrectWorkflowToken = Array.from(outBinds).some(bind => 
          bind.getAttribute("type") === "WorkflowToken" && 
          bind.getAttribute("name") === "wfToken"
        );
        
        // All conditions must be met
        const isAsyncWorkflow = hasLaunchedWorkflowId && hasCorrectWorkflowToken;
        
        if (isAsyncWorkflow) {
          const itemName = item.getAttribute("name");
          console.log(`Async workflow detected for item ${itemName}`, {
            hasLaunchedWorkflowId,
            hasCorrectWorkflowToken,
            outBindings: Array.from(outBinds).map(b => b.outerHTML)
          });
          return "icons/workflow-async.svg";
        }
      }
      
      // Special case: Task with script-module should use action icon
      if ((type === "task" || type === "scriptable-task") && (scriptModule || scriptModule === "")) {
        return "icons/action.svg";
      }
      
      // Special case: Schedule workflow - check for both task and scriptable-task types
      if (type === "task" || type === "scriptable-task") {
        const itemName = item.getAttribute("name");
        const displayName = item.getElementsByTagName("display-name")[0]?.textContent;
        
        // Get bindings
        const inBinds = item.getElementsByTagName("in-binding")[0]?.getElementsByTagName("bind") || [];
        const outBinds = item.getElementsByTagName("out-binding")[0]?.getElementsByTagName("bind") || [];
        
        // Log details for debugging
        console.log(`Checking schedule workflow for item: ${itemName} (${displayName || 'no display name'})`);
        
        let hasScheduleInput = false;
        let hasScheduleOutput = false;
        
        // Check for workflowScheduleDate in input bindings
        for (let bind of inBinds) {
          if (bind.getAttribute("name") === "workflowScheduleDate") {
            hasScheduleInput = true;
            break;
          }
        }
        
        // Check for scheduledTask in output bindings
        for (let bind of outBinds) {
          if (bind.getAttribute("name") === "scheduledTask") {
            hasScheduleOutput = true;
            break;
          }
        }
        
        // If both required bindings are present, it's a schedule workflow
        if (hasScheduleInput && hasScheduleOutput) {
          console.log(`Schedule workflow detected for item ${itemName} (${displayName || 'no display name'})`);
          console.log('Found schedule workflow by bindings:', {itemName, displayName});
          return "icons/workflow-schedule.svg";
        }
        
        // Also check display name as a fallback
        if (displayName && displayName.includes("Schedule")) {
          console.log('Found schedule workflow by display name:', displayName);
          return "icons/workflow-schedule.svg";
        }
      }

      if (prototypeId && iconMapping[type + ":prototype-id=" + prototypeId]) {
        return iconMapping[type + ":prototype-id=" + prototypeId];
      }
      // Debug: Log the final icon selection
      const finalIcon = iconMapping[type] || iconMapping["default"];
      console.log('Final icon selection for', type, ':', finalIcon);
      return finalIcon;
    }

    // Function to show messages to user
    function showMessage(message, type = 'info') {
      const messagesDiv = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = type;
      messageDiv.textContent = message;
      messagesDiv.innerHTML = '';
      messagesDiv.appendChild(messageDiv);

      // Auto-hide after 5 seconds
      setTimeout(() => {
        messagesDiv.innerHTML = '';
      }, 5000);
    }

    // Function to create node positions using simple layout algorithm
    // Replace the calculateNodePositions function with this improved version
    function calculateNodePositions(workflowItems) {
      const positions = {};
      const nodeWidth = 120;
      const nodeHeight = 100;
      let minX = Infinity, minY = Infinity;

      workflowItems.forEach(item => {
        const posElem = item.getElementsByTagName("position")[0];
        if (posElem) {
          const x = parseFloat(posElem.getAttribute("x")) || 0;
          const y = parseFloat(posElem.getAttribute("y")) || 0;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
        }
      });

      // Use different scales for x and y
      const scaleX = 1.5; // Try 3, 4, or 5 for tighter layout
      const scaleY = 3; // Keep as is, or adjust for vertical spacing

      workflowItems.forEach(item => {
        const name = item.getAttribute("name");
        const posElem = item.getElementsByTagName("position")[0];
        let x = 0, y = 0;
        if (posElem) {
          x = (parseFloat(posElem.getAttribute("x")) || 0) - minX;
          y = (parseFloat(posElem.getAttribute("y")) || 0) - minY;
        }
        positions[name] = {
          x: x * scaleX + 60,
          y: y * scaleY + 60,
          width: nodeWidth,
          height: nodeHeight
        };
      });

      // Calculate minimum x among all nodes
      minX = Math.min(...Object.values(positions).map(p => p.x));
      // Desired left margin for the start node
      const leftMargin = 60;
      const startNodeWidth = 120;
      const offset = leftMargin + startNodeWidth + 20 - minX; // 20px gap after start node
      // Shift all nodes to the right by 'offset'
      Object.values(positions).forEach(pos => {
        pos.x += offset;
      });

      return positions;
    }

    // Fallback simple grid layout
    function simpleGridLayout(workflowItems) {
      const positions = {};
      const nodeWidth = 120;
      const nodeHeight = 100;
      const horizontalSpacing = 180;
      const verticalSpacing = 150;
      
      workflowItems.forEach((item, index) => {
        const name = item.getAttribute("name");
        const row = Math.floor(index / 4);
        const col = index % 4;
        
        positions[name] = {
          x: col * horizontalSpacing + 60,
          y: row * verticalSpacing + 60,
          width: nodeWidth,
          height: nodeHeight
        };
      });
      
      return positions;
    }
    // Function to create arrow path between two points (center to center)
    function createArrowPath(x1, y1, x2, y2, isDotted = false) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const length = Math.sqrt(dx * dx + dy * dy);
      if (length === 0) return '';
      const unitX = dx / length;
      const unitY = dy / length;
      const nodeWidth = 120;
      const nodeHeight = 100;
      const verticalOffset = nodeHeight * 0.1;
      const startX = x1 + unitX * (nodeWidth / 2);
      const startY = y1 - verticalOffset + unitY * (nodeHeight / 2);
      const endX = x2 - unitX * (nodeWidth / 2);
      const endY = y2 - verticalOffset - unitY * (nodeHeight / 2);
      
      // For dotted arrows, create a dashed line
      if (isDotted) {
        const dashLength = 4;
        const gapLength = 4;
        const totalLength = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
        const numDashes = Math.floor(totalLength / (dashLength + gapLength));
        
        let path = `M${startX},${startY}`;
        for (let i = 0; i < numDashes; i++) {
          const t = i / numDashes;
          const dashX = startX + t * (endX - startX);
          const dashY = startY + t * (endY - startY);
          path += ` L${dashX},${dashY}`;
          if (i < numDashes - 1) {
            const gapX = dashX + (gapLength / totalLength) * (endX - startX);
            const gapY = dashY + (gapLength / totalLength) * (endY - startY);
            path += ` M${gapX},${gapY}`;
          }
        }
        return path;
      }
      
      return `M${startX},${startY} L${endX},${endY}`;
    }

    let workflowName = "workflow"; // Default name

    function extractWorkflowName(xmlDoc) {
      const nameElement = xmlDoc.querySelector("workflow > display-name");
      return nameElement ? nameElement.textContent : "workflow";
    }

    function displayWorkflowName(name) {
      // Remove any existing workflow name header
      const existingHeader = document.querySelector('.details h1');
      if (existingHeader) {
        existingHeader.remove();
      }
      
      // Add new workflow name with improved styling
      const detailsContainer = document.querySelector('.details');
      const detailsHeader = document.createElement('h1');
      detailsHeader.textContent = `Workflow Name: ${name}`;
      detailsHeader.style.cssText = `
        margin-bottom: 30px;
        font-size: 28px;
        font-weight: 700;
        color: #007cbb;
        text-align: center;
        padding: 15px 20px;
        background-color: #ffffff;
        border-bottom: 3px solid #007cbb;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        border-radius: 4px;
      `;
      detailsContainer.insertBefore(detailsHeader, detailsContainer.firstChild);
    }

    document.getElementById('fileUpload').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) {
        showMessage('Please upload a file first.', 'error');
        return;
      }
      // showMessage('Processing workflow...', 'success');
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const workflowXML = event.target.result;
          const parser = new DOMParser();
          const xmlDoc = parser.parseFromString(workflowXML, "application/xml");
          if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
            throw new Error('Error parsing XML file. Please check the file format.');
          }

          // Extract and set the workflow name
          workflowName = extractWorkflowName(xmlDoc);
          displayWorkflowName(workflowName);

          const workflowItems = Array.from(xmlDoc.getElementsByTagName("workflow-item"));
          const inputs = Array.from(xmlDoc.getElementsByTagName("input")[0]?.getElementsByTagName("param") || []);
          const outputs = Array.from(xmlDoc.getElementsByTagName("output")[0]?.getElementsByTagName("param") || []);
          if (workflowItems.length === 0) {
            throw new Error('No workflow items found in the XML file.');
          }
          // Patch: treat type=task with no prototype-id and no script-module as scriptable-task
          workflowItems.forEach(item => {
            const type = item.getAttribute("type");
            if (type === "task" && !item.hasAttribute("prototype-id") && !item.hasAttribute("script-module")) {
              // Check if this is an async workflow task before converting
              const hasLaunchedWorkflowId = item.hasAttribute("launched-workflow-id");
              const outBinds = item.getElementsByTagName("out-binding")[0]?.getElementsByTagName("bind") || [];
              const hasCorrectWorkflowToken = Array.from(outBinds).some(bind => 
                bind.getAttribute("type") === "WorkflowToken" && 
                bind.getAttribute("name") === "wfToken"
              );
              
              // Only convert to scriptable-task if it's not an async workflow
              if (!(hasLaunchedWorkflowId && hasCorrectWorkflowToken)) {
                item.setAttribute("type", "scriptable-task");
              } else {
                console.log('Preserving task type for async workflow item:', item.getAttribute("name"));
              }
            }
          });
          // Calculate positions for nodes
          const positions = calculateNodePositions(workflowItems);
          // Calculate SVG dimensions
          const maxX = Math.max(...Object.values(positions).map(p => p.x + p.width));
          const maxY = Math.max(...Object.values(positions).map(p => p.y + p.height));
          const svgWidth = maxX + 60;
          const svgHeight = maxY + 60;
          // Create SVG with background and foreignObject nodes
          let svgContent = `<svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}">
  <defs>
    <pattern id="dotGrid" width="18" height="18" patternUnits="userSpaceOnUse">
      <circle cx="9" cy="9" r="1" fill="#cbd4d8" />
    </pattern>
    <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="5" markerHeight="6" orient="auto">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="#0079ad"/>
    </marker>
    <marker id="arrow-green" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="5" markerHeight="6" orient="auto">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="green"/>
    </marker>
    <marker id="arrow-red" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="5" markerHeight="6" orient="auto">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="red"/>
    </marker>
    <marker id="catchArrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="6" markerHeight="6" orient="auto">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="red"/>
    </marker>
  </defs>
  <rect width="100%" height="100%" fill="url(#dotGrid)" />
`;

          // --- Error Handler Nodes ---
          // Find all error-handler elements
          const errorHandlers = Array.from(xmlDoc.getElementsByTagName("error-handler"));
          // Build a list of error handler nodes to add
          const errorHandlerNodes = [];
          errorHandlers.forEach(eh => {
            const targetName = eh.getAttribute("name");
            if (targetName && positions[targetName]) {
              // Position error handler node to the left of the referenced node
              const targetPos = positions[targetName];
              const errorHandlerName = `error-handler-${targetName}`;
              // Place flush with left margin, same y as target
              const errorHandlerX = 60; // left margin
              const errorHandlerY = targetPos.y;
              positions[errorHandlerName] = {
                x: errorHandlerX,
                y: errorHandlerY,
                width: targetPos.width,
                height: targetPos.height
              };
              // Get the referenced node's position
              const refPos = positions[targetName];
              if (refPos) {
                // Position error handler to the left of the target node at the same level
                const ehX = refPos.x - 200; // 100 pixels to the left
                const ehY = refPos.y; // Same y-coordinate as target node
                errorHandlerNodes.push({
                  name: errorHandlerName,
                  label: "Error handler",
                  icon: "icons/error-handler.svg",
                  target: targetName,
                  pos: {
                    x: ehX,
                    y: ehY,
                    width: 120,
                    height: 100
                  }
                });
              } else {
                console.warn(`Could not find position for target node ${targetName}`);
              }
            }
          });

          // --- Render nodes ---
          // Add error handler nodes first
          errorHandlerNodes.forEach(eh => {
            svgContent += `
            <!-- Error Handler Node: ${eh.name} -->
            <g transform="translate(${eh.pos.x},${eh.pos.y})">
              <foreignObject width="${eh.pos.width}" height="${eh.pos.height}">
                <div xmlns="http://www.w3.org/1999/xhtml" style="
                  display: inline-block;
                  text-align: center;
                  font-family: 'Metropolis', Arial, sans-serif;
                  font-size: 12px;
                  width: 100%;
                  height: 100%;
                ">
                  <img src="${eh.icon}" 
                       width="40" height="40" 
                       style="display: block; margin: 0 auto;"
                       onerror="this.style.display='none'"/>
                  <div style="margin-top: 5px; font-weight: 700; font-family: 'Metropolis', Arial, sans-serif;">
                    ${eh.label}
                  </div>
                </div>
              </foreignObject>
            </g>`;
          });

          // Add regular workflow nodes
          console.log('=== Processing workflow items for diagram ===');
          workflowItems.forEach(item => {
            const name = item.getAttribute("name");
            let type = item.getAttribute("type") || "default";
            let displayName = item.getElementsByTagName("display-name")[0]?.textContent || name;
            console.log(`Diagram - Item: ${name}, Type: ${type}, Initial Display Name: "${displayName}"`);
            
            // Special handling for custom conditions to ensure they're properly displayed
            if (type === "custom-condition") {
              // Use the display name or fall back to the name without the "item" prefix
              displayName = displayName || name.replace(/^item\d+_?/, '');
              if (!displayName && name.startsWith("item")) {
                displayName = name.replace(/^item(\d+)/, 'Condition $1');
              }
            }
            // If type is 'link', treat as 'workflow'
            if (type === 'link') {
              type = 'workflow';
              displayName = 'workflow';
            }
            // For end nodes, always show 'End' as the label
            if (type === 'end') {
              displayName = 'End';
            }
            const icon = getIconForNode(item);
            const color = colorMapping[type] || colorMapping.default;
            const pos = positions[name];
            let nodeText = displayName;
            
            // For workflow and link types, use display-name if available
            if (type === 'workflow' || type === 'link') {
              const displayNameElement = item.getElementsByTagName('display-name')[0];
              if (displayNameElement) {
                nodeText = displayNameElement.textContent;
              }
            }

            // Create a clickable link around each node
            const nodeId = `node-${name}`;
            svgContent += `
            <!-- Node: ${name} -->
            <g transform="translate(${pos.x},${pos.y})" class="node-group" data-node-id="${name}">
              <a href="#${nodeId}" style="text-decoration: none; color: inherit; display: block; width: 100%; height: 100%;">
                <foreignObject width="${pos.width}" height="${pos.height}">
                  <div xmlns="http://www.w3.org/1999/xhtml" style="
                    display: inline-block;
                    text-align: center;
                    font-family: 'Metropolis', Arial, sans-serif;
                    font-size: 12px;
                    width: 100%;
                    height: 100%;
                    cursor: pointer;
                    border-radius: 8px;
                    transition: all 0.2s ease;
                    position: relative;
                    z-index: 1;
                  " class="node-container">
                    <div style="
                      position: absolute;
                      top: 0;
                      left: 0;
                      right: 0;
                      bottom: 0;
                      background: rgba(0, 124, 187, 0);
                      border-radius: 8px;
                      transition: background 0.2s ease;
                      z-index: -1;
                    " class="node-highlight"></div>
                    <img src="${icon}" 
                         width="40" height="40" 
                         style="display: block; margin: 0 auto;"
                         onerror="this.style.display='none'"
                         class="node-icon"/>
                    <div style="margin-top: 5px; font-weight: 700; font-family: 'Metropolis', Arial, sans-serif;" class="node-label">
                      ${nodeText}
                    </div>
                  </div>
                </foreignObject>
              </a>
              <!-- Add hover and active styles -->
              <style>
                .node-group:hover .node-highlight {
                  background: rgba(0, 124, 187, 0.1) !important;
                }
                .node-group:active .node-highlight {
                  background: rgba(0, 124, 187, 0.2) !important;
                }
                .node-group:focus .node-highlight {
                  box-shadow: 0 0 0 2px rgba(0, 124, 187, 0.3);
                }
              </style>
            </g>`;
          });

          // Add connections/arrows
          workflowItems.forEach(item => {
            const name = item.getAttribute("name");
            const outName = item.getAttribute("out-name");
            const altOutName = item.getAttribute("alt-out-name");
            const catchName = item.getAttribute("catch-name");
            const type = item.getAttribute("type") || "default";
            
            const fromPos = positions[name];
            const fromX = fromPos.x + fromPos.width / 2;
            const fromY = fromPos.y + fromPos.height / 2;

            if (outName && positions[outName]) {
              const toPos = positions[outName];
              const toX = toPos.x + toPos.width / 2;
              const toY = toPos.y + toPos.height / 2;
              
              const isDecision = type === "condition" || type === "decision" || type === "custom-condition" || type === "decision-activity";
              const arrowColor = isDecision ? "green" : "#0079ad";
              const markerId = isDecision ? "arrow-green" : "arrow";
              const pathData = createArrowPath(fromX, fromY, toX, toY);
              
              if (pathData) {
                svgContent += `
                <path d="${pathData}" stroke="${arrowColor}" stroke-width="1.5" fill="none" marker-end="url(#${markerId})"/>`;
              }
            }

            if (altOutName && positions[altOutName]) {
              const toPos = positions[altOutName];
              const toX = toPos.x + toPos.width / 2;
              const toY = toPos.y + toPos.height / 2;
              
              const pathData = createArrowPath(fromX, fromY, toX, toY);
              
              if (pathData) {
                svgContent += `
                <path d="${pathData}" stroke="red" stroke-width="2" stroke-dasharray="5,5" fill="none" marker-end="url(#arrow-red)"/>`;
              }
            }

            if (catchName && positions[catchName]) {
              const toPos = positions[catchName];
              const toX = toPos.x + toPos.width / 2;
              const toY = toPos.y + toPos.height / 2;
              
              const pathData = createArrowPath(fromX, fromY, toX, toY);
              
              if (pathData) {
                svgContent += `
                <path d="${pathData}" stroke="red" stroke-width="1.5" fill="none" stroke-dasharray="4,4" marker-end="url(#catchArrow)"/>`;
              }
            }
          });

          // --- Render error handler arrows ---
          errorHandlerNodes.forEach(eh => {
            // Draw from center of error handler node to center of target node using createArrowPath
            const fromX = eh.pos.x + eh.pos.width / 2;
            const fromY = eh.pos.y + eh.pos.height / 2;
            const toPos = positions[eh.target];
            const toX = toPos.x + toPos.width / 2;
            const toY = toPos.y + toPos.height / 2;
            const pathData = createArrowPath(fromX, fromY, toX, toY);
            svgContent += `<path d="${pathData}" stroke="#0079ad" stroke-width="1.5" fill="none" marker-end="url(#arrow)"/>`;
          });

          // Add start node before root-name item
          const rootName = xmlDoc.querySelector("workflow").getAttribute("root-name");
          if (rootName && positions[rootName]) {
            const rootPos = positions[rootName];
            const startNodeX = rootPos.x - 180;
            const startNodeY = rootPos.y;
            
            // Add start node
            svgContent += `
            <g transform="translate(${startNodeX},${startNodeY})">
              <foreignObject width="120" height="100">
                <div xmlns="http://www.w3.org/1999/xhtml" style="
                  display: inline-block;
                  text-align: center;
                  font-family: 'Metropolis', Arial, sans-serif;
                  font-size: 12px;
                  width: 100%;
                  height: 100%;
                ">
                  <img src="icons/start.svg" width="40" height="40" style="display: block; margin: 0 auto;"/>
                  <div style="margin-top: 5px; font-weight: 700; font-family: 'Metropolis', Arial, sans-serif;">Start</div>
                </div>
              </foreignObject>
            </g>
            `;
            
            // Add arrow from start node to root node
            const fromX = startNodeX + 60;
            const fromY = startNodeY + 50;
            const toX = rootPos.x + rootPos.width / 2;
            const toY = rootPos.y + rootPos.height / 2;
            const pathData = createArrowPath(fromX, fromY, toX, toY);
            svgContent += `<path d="${pathData}" stroke="#0079ad" stroke-width="1.5" fill="none" marker-end="url(#arrow)"/>`;
          }

          // Add switch arrows
          const switchArrows = createSwitchArrows(workflowItems, positions);
          svgContent += switchArrows;

          svgContent += '</svg>';

          // Hide welcome box, show graph, details, and download buttons
          document.querySelector('.welcome-box').style.display = 'none';
          const graphZoomContainer = document.getElementById("graphZoomContainer");
          
          // Show download buttons and zoom controls
          document.getElementById('downloadSvgBtn').style.display = 'inline-block';
          document.getElementById('downloadHtmlBtn').style.display = 'inline-block';
          document.getElementById('zoomControls').style.display = 'flex';
          graphZoomContainer.style.display = '';
          const graphDiv = document.getElementById("graph");
          graphDiv.style.display = '';
          const detailsDiv = document.querySelector('.details');
          detailsDiv.style.display = '';
          
          // Show zoom controls after workflow upload
          const zoomControls = document.getElementById('zoomControls');
          if (zoomControls) zoomControls.style.display = '';
          graphDiv.innerHTML = svgContent;
          
          // Show floating buttons after workflow is processed
          if (window.toggleWorkflowUI) {
            window.toggleWorkflowUI(true);
          }
          // Update details section
          updateDetails(xmlDoc, workflowItems, inputs, outputs);
          //showMessage('Workflow processed successfully!', 'success');
          // Reset zoom on new diagram
          currentZoom = 1.0;
          const svg = graphDiv.querySelector('svg');
          if (svg) {
            svg.style.transform = `scale(${currentZoom})`;
            svg.style.transformOrigin = 'top left';
            svg.style.display = 'block';
          }

        } catch (error) {
          console.error('Error processing file:', error);
          showMessage(`Error: ${error.message}`, 'error');
        }
      };
      reader.readAsText(file);
    });
    
    function updateDetails(xmlDoc, workflowItems, inputs, outputs) {
          const detailsDiv = document.getElementById("details");
      // Clear existing content first
      detailsDiv.innerHTML = '';
      
      // Workflow-level details
      const workflowInputs = inputs.map(input => 
        `<tr><td>${input.getAttribute("name")}</td><td>${input.getAttribute("type")}</td></tr>`
      ).join("") || "<tr><td colspan='2'>No workflow inputs</td></tr>";
      const workflowOutputs = outputs.map(output => 
        `<tr><td>${output.getAttribute("name")}</td><td>${output.getAttribute("type")}</td></tr>`
      ).join("") || "<tr><td colspan='2'>No workflow outputs</td></tr>";
          const workflowAttributes = Array.from(xmlDoc.getElementsByTagName("attrib")).map(attr => {
            const name = attr.getAttribute("name");
            const type = attr.getAttribute("type");
            const value = attr.getElementsByTagName("value")[0]?.textContent || "No value";
        return `<tr><td>${name}</td><td>${type}</td><td>${value}</td></tr>`;
      }).join("") || "<tr><td colspan='3'>No workflow attributes</td></tr>";
      // Workflow items details (skip end/item0 nodes)
      console.log('=== Processing workflow items for details ===');
      const itemsDetails = workflowItems.filter(item => {
        const name = item.getAttribute("name");
        const type = item.getAttribute("type") || "default";
        const displayName = item.getElementsByTagName("display-name")[0]?.textContent || name;
        console.log(`Item: ${name}, Type: ${type}, Display Name: "${displayName}"`);
        
        // Only exclude end nodes
        const include = type !== "end";
        if (!include) {
          console.log(`  - Excluding item ${name} (type: ${type})`);
        }
        return include;
      }).map(item => {
        const name = item.getAttribute("name");
        let type = item.getAttribute("type") || "default";
        let displayName = item.getElementsByTagName("display-name")[0]?.textContent || name;
        
        // Special handling for custom conditions to ensure they're properly displayed
        if (type === "custom-condition") {
          // Use the display name or fall back to the name without the "item" prefix
          displayName = displayName || name.replace(/^item\d+_?/, '');
          if (!displayName && name.startsWith("item")) {
            displayName = name.replace(/^item(\d+)/, 'Condition $1');
          }
        }
        const itemInputs = Array.from(item.getElementsByTagName("in-binding")[0]?.getElementsByTagName("bind") || []);
        const itemOutputs = Array.from(item.getElementsByTagName("out-binding")[0]?.getElementsByTagName("bind") || []);
        const scriptElement = item.getElementsByTagName("script")[0];
        const script = scriptElement?.textContent || "";
        const scriptId = `monaco-script-${name}`;
        
        // Debug logging for script content
        console.log(`Item ${name} (${displayName}) script content:`, {
          hasScriptElement: !!scriptElement,
          hasEncodedAttr: scriptElement?.hasAttribute('encoded'),
          scriptContent: script,
          scriptElement: scriptElement
        });
        const nodeId = `node-${name}`;
        return `
          <div id="${nodeId}" class="workflow-item" style="margin-bottom: 20px; padding: 10px 0;">
            <h4 style="margin-top: 0; color: #007cbb;">
              ${displayName} (${type})
            </h4>
            <table border="1">
              <tr>
                <th colspan="2">Inputs</th>
                <th colspan="2">Outputs</th>
              </tr>
              <tr>
                <td colspan="2">
                  ${itemInputs.length > 0 ? 
                    `<table><tr><th>Name</th><th>Type</th></tr>
                    ${itemInputs.map(input => 
                      `<tr><td>${input.getAttribute("name")}</td><td>${input.getAttribute("type")}</td></tr>`
                    ).join("")}</table>` 
                    : "No inputs"}
                </td>
                <td colspan="2">
                  ${itemOutputs.length > 0 ? 
                    `<table><tr><th>Name</th><th>Type</th></tr>
                    ${itemOutputs.map(output => 
                      `<tr><td>${output.getAttribute("name")}</td><td>${output.getAttribute("type")}</td></tr>`
                    ).join("")}</table>` 
                    : "No outputs"}
                </td>
              </tr>
              <tr>
                <td colspan="4">
                  <strong>Script:</strong>
                  ${script ? `<div id="${scriptId}" class="monaco-script" style="height:${script.split('\n').length > 2 ? '300px' : '50px'};border:1px solid #eee;"></div>` : '<div class="no-script">No script content</div>'}
                </td>
              </tr>
            </table>
          </div>
        `;
      }).join("");
      detailsDiv.innerHTML = `
        <div class="details-section-heading">Workflow-Level Details</div>
        <table border="1">
          <tr>
            <th colspan="2">Input Parameters</th>
            <th colspan="2">Output Parameters</th>
          </tr>
          <tr>
            <td colspan="2">
              ${workflowInputs ? `<table><tr><th>Name</th><th>Type</th></tr>${workflowInputs}</table>` : "No inputs"}
            </td>
            <td colspan="2">
              ${workflowOutputs ? `<table><tr><th>Name</th><th>Type</th></tr>${workflowOutputs}</table>` : "No outputs"}
            </td>
          </tr>
          <tr>
            <th colspan="4">Workflow Attributes</th>
          </tr>
          <tr>
            <td colspan="4">
              ${workflowAttributes ? `<table><tr><th>Name</th><th>Type</th><th>Value</th></tr>${workflowAttributes}</table>` : "No attributes"}
            </td>
          </tr>
        </table>
        <div class="details-section-heading">Workflow Items</div>
        ${itemsDetails}
      `;
      // Initialize Monaco Editor for each script
      if (typeof require !== 'undefined') {
        require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.44.0/min/vs' } });
        require(['vs/editor/editor.main'], function () {
          workflowItems.forEach(item => {
            const name = item.getAttribute("name");
            const type = item.getAttribute("type") || "default";
            const scriptElement = item.getElementsByTagName("script")[0];
            let scriptContent = scriptElement?.textContent || "";
            
            // Special handling for custom conditions
            if (type === "custom-condition") {
              // Get the script content directly from the script element
              scriptContent = scriptElement ? scriptElement.textContent.trim() : "";
            } else {
              // For other types, use the existing logic
              scriptContent = item.getElementsByTagName("script")[0]?.textContent.trim() || "";
            }
            
            console.log(`Initializing Monaco for ${name} (${type}):`, {
              hasScriptElement: !!scriptElement,
              scriptLength: scriptContent.length,
              scriptPreview: scriptContent.substring(0, 50) + (scriptContent.length > 50 ? '...' : '')
            });
            
            if (type === "end") return;
            
            const scriptId = `monaco-script-${name}`;
            const el = document.getElementById(scriptId);
            if (!el) {
              console.log(`Element not found for script ID: ${scriptId}`);
              return;
            }
            
            if (!scriptContent) {
              el.innerHTML = '<div class="no-script">No script available</div>';
              return;
            }
            
            const lineCount = scriptContent.split('\n').length;
            // Calculate height based on line count and average line height
            const avgLineHeight = 18.05; // Average line height in pixels
            const editorHeight = lineCount * avgLineHeight;
            monaco.editor.create(el, {
              value: scriptContent,
              language: 'javascript',
              minimap: { enabled: false },
              scrollBeyondLastLine: false,
              automaticLayout: true,
              theme: 'vs', // Changed from 'vs-dark' to 'vs'
              lineNumbers: 'on',
              fontSize: 12,
              lineHeight: 18,
              readOnly: true
            });
            
            el.style.height = `${editorHeight}px`;
          });
        });
      }
    }

    // Add click handler to title to return to welcome note view
    document.addEventListener('DOMContentLoaded', function() {
      const title = document.getElementById('mainTitle');
      if (title) {
        title.addEventListener('click', function() {
          // Use the same logic as home button
          const homeBtn = document.getElementById('homeBtn');
          if (homeBtn) homeBtn.click();
        });
      }
    });

    // Function to create a PNG of the diagram
    async function createDiagramImage() {
      const svgElement = document.querySelector('svg');
      if (!svgElement) {
        throw new Error('No diagram content found');
      }

      // Create a temporary container to hold the SVG
      const container = document.createElement('div');
      container.style.position = 'fixed';
      container.style.top = '-9999px';
      container.style.background = 'white';
      container.style.padding = '20px';
      
      // Clone the SVG and its parent to maintain styles
      const svgClone = svgElement.cloneNode(true);
      container.appendChild(svgClone);
      document.body.appendChild(container);

      // Function to convert images to data URLs
      async function convertImagesToDataUrls(element) {
        const images = element.querySelectorAll('image, img');
        const promises = [];
        
        for (const img of images) {
          const src = img.getAttribute('xlink:href') || img.src;
          if (!src) continue;
          
          const promise = new Promise((resolve) => {
            const imgEl = new Image();
            imgEl.crossOrigin = 'Anonymous';
            imgEl.onload = () => {
              try {
                const canvas = document.createElement('canvas');
                canvas.width = imgEl.width || 24;
                canvas.height = imgEl.height || 24;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(imgEl, 0, 0);
                const dataUrl = canvas.toDataURL('image/png');
                if (img.tagName.toLowerCase() === 'image') {
                  img.setAttribute('xlink:href', dataUrl);
                } else {
                  img.src = dataUrl;
                }
              } catch (e) {
                console.error('Error converting image:', e);
              }
              resolve();
            };
            imgEl.onerror = () => {
              console.warn('Failed to load image:', src);
              resolve();
            };
            imgEl.src = src;
          });
          
          promises.push(promise);
        }
        
        return Promise.all(promises);
      }

      try {
        // Convert all images to data URLs
        await convertImagesToDataUrls(svgClone);

        // Use html2canvas to convert SVG to canvas
        const canvas = await html2canvas(container, {
          scale: 2,
          useCORS: true,
          logging: false,
          allowTaint: true,
          backgroundColor: 'white',
          onclone: (clonedDoc) => {
            const clonedSvg = clonedDoc.querySelector('svg');
            if (clonedSvg) {
              clonedSvg.style.display = 'block';
              clonedSvg.style.overflow = 'visible';
            }
            const foreignObjects = clonedDoc.querySelectorAll('foreignObject');
            foreignObjects.forEach(fo => {
              fo.style.overflow = 'visible';
              const content = fo.querySelector('div');
              if (content) {
                content.style.display = 'block';
                content.style.overflow = 'visible';
              }
            });
          }
        });

        return canvas.toDataURL('image/png');
      } finally {
        // Clean up
        document.body.removeChild(container);
      }
    }


    // Download as PDF logic
    async function downloadAsPDF() {
      try {
        const { jsPDF } = window.jspdf;
        const detailsContainer = document.querySelector('.details');

        // Create a new jsPDF instance
        const pdf = new jsPDF('p', 'pt', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();

        // Create the diagram image
        const diagramDataUrl = await createDiagramImage();
        
        // Add diagram as first page
        const imgProps = pdf.getImageProperties(diagramDataUrl);
        const imgWidth = pageWidth - 40; // Add some margin
        const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
        
        // Add diagram page (landscape)
        pdf.addPage([Math.max(pageWidth, imgWidth + 40), Math.max(pageHeight, imgHeight + 40)], 'l');
        pdf.addImage(diagramDataUrl, 'PNG', 20, 20, imgWidth, imgHeight, undefined, 'FAST');

        // Add details pages (portrait)
        if (detailsContainer) {
          const detailsCanvas = await html2canvas(detailsContainer, {
            scale: 2,
            logging: false,
            useCORS: true,
            allowTaint: true,
            backgroundColor: 'white'
          });
          
          const detailsDataUrl = detailsCanvas.toDataURL('image/png');
          const detailsProps = pdf.getImageProperties(detailsDataUrl);
          const detailsImgWidth = pageWidth - 40; // Add some margin
          const detailsImgHeight = (detailsProps.height * detailsImgWidth) / detailsProps.width;
          
          // Add details pages with pagination if needed
          let heightLeft = detailsImgHeight;
          let position = 20; // Start position
          let pageNum = 1;
          
          pdf.addPage(); // Add a new page for details
          
          while (heightLeft > 0) {
            pdf.addImage(detailsDataUrl, 'PNG', 20, position, detailsImgWidth, detailsImgHeight, undefined, 'FAST');
            heightLeft -= (pageHeight - 40); // Account for margins
            position -= (pageHeight - 40);
            
            if (heightLeft > 0) {
              pdf.addPage();
              pageNum++;
            }
          }
        }

        
        // Save the PDF with the workflow name
        pdf.save(`${workflowName}.pdf`);
        
      } catch (error) {
        console.error('Error generating PDF:', error);
        showMessage('Error generating PDF. Please try again.', 'error');
      }
    }

    // Function to embed all icons in the SVG
    async function embedIconsInSvg(svgElement) {
      const svgClone = svgElement.cloneNode(true);
      const images = svgClone.querySelectorAll('image, img');
      
      for (const img of images) {
        const src = img.getAttribute('xlink:href') || img.src;
        if (!src) continue;
        
        try {
          const response = await fetch(src);
          if (!response.ok) throw new Error('Failed to fetch image');
          
          const blob = await response.blob();
          const reader = new FileReader();
          
          await new Promise((resolve, reject) => {
            reader.onload = (e) => {
              try {
                const dataUrl = e.target.result;
                if (img.tagName.toLowerCase() === 'image') {
                  img.setAttribute('xlink:href', dataUrl);
                } else {
                  img.src = dataUrl;
                }
                resolve();
              } catch (e) {
                reject(e);
              }
            };
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        } catch (error) {
          console.warn(`Could not embed image: ${src}`, error);
        }
      }
      
      return svgClone;
    }

    // Function to embed all SVG icons as data URLs
    async function embedSvgIcons(element) {
      const images = element.querySelectorAll('img[src$=".svg"]');
      
      for (const img of images) {
        try {
          const response = await fetch(img.src);
          if (!response.ok) continue;
          
          const svgText = await response.text();
          const svgDataUrl = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svgText)))}`;
          img.src = svgDataUrl;
        } catch (error) {
          console.warn('Failed to embed SVG:', img.src, error);
        }
      }
    }

    // Function to update progress
    function updateProgress(progress, message) {
      const progressBar = document.querySelector('#progressContainer .progress-bar');
      const statusElement = document.querySelector('#progressContainer .progress-status');
      if (progressBar) progressBar.value = progress;
      if (statusElement && message) statusElement.textContent = message;
    }

    // Function to show/hide progress
    function showProgress(show) {
      const container = document.getElementById('progressContainer');
      const overlay = document.getElementById('overlay');
      if (show) {
        container.style.display = 'block';
        overlay.style.display = 'block';
      } else {
        container.style.display = 'none';
        overlay.style.display = 'none';
      }
    }

    // Function to download the page as HTML with proper filename and styling
    async function downloadAsHTML() {
      try {
        // Show progress
        showProgress(true);
        updateProgress(10, 'Preparing HTML content...');
        await new Promise(resolve => setTimeout(resolve, 300)); // Small delay for UI update
        // Clone the document and modify it for saving
        updateProgress(20, 'Cloning document...');
        
        // Create a deep clone of the document but exclude the progress elements
        const doc = document.cloneNode(true);
        
        // Remove UI elements that shouldn't be in the downloaded HTML
        const elementsToRemove = ['progressContainer', 'overlay', 'goToTopBtn', 'homeBtn', 'footer'];
        elementsToRemove.forEach(id => {
          const element = doc.getElementById(id);
          if (element && element.parentNode) {
            element.parentNode.removeChild(element);
          }
        });
        
        // Remove the top bar, title, and footers
        updateProgress(30, 'Cleaning up content...');
        const topBar = doc.querySelector('.top-bar');
        if (topBar) topBar.remove();
        
        // Remove footer elements
        const footers = doc.querySelectorAll('footer, .footer-note');
        footers.forEach(footer => {
          if (footer && footer.parentNode) {
            footer.parentNode.removeChild(footer);
          }
        });
        
        // Embed SVG icons
        updateProgress(50, 'Processing images and icons...');
        await embedSvgIcons(doc);
        
        updateProgress(70, 'Preparing download...');
        // Use the workflow name directly for HTML files
        const fileName = `${workflowName || 'workflow'}.html`;
        
        // Create a blob with the HTML content
        updateProgress(80, 'Generating file...');
        const htmlContent = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
        const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
        
        // Create a download link
        updateProgress(90, 'Creating download link...');
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        // Set the download attributes
        link.href = url;
        link.download = fileName;
        
        // Append to body, trigger download, and clean up
        document.body.appendChild(link);
        link.click();
        
        // Clean up and complete
        updateProgress(100, 'Download starting...');
        setTimeout(() => {
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          showProgress(false);
        }, 300);
        
      } catch (error) {
        showProgress(false);
        console.error('Error saving HTML:', error);
        showMessage('Error generating HTML: ' + error.message, 'error');
        // Fall back to browser's save as
        const win = window.open('', '_blank');
        win.document.open();
        win.document.write(`
          <!DOCTYPE html>
          <html>
          <head>
            <title>Save Workflow Documentation</title>
            <style>
              body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; }
              .container { background: #f9f9f9; padding: 20px; border-radius: 5px; margin-top: 20px; }
              code { background: #f0f0f0; padding: 2px 5px; border-radius: 3px; }
            </style>
          </head>
          <body>
            <h1>Save Workflow Documentation</h1>
            <div class="container">
              <p>To save this workflow documentation:</p>
              <ol>
                <li>Right-click anywhere on this page</li>
                <li>Select <strong>Save As...</strong> (or <strong>Save Page As...</strong>)</li>
                <li>Choose "Webpage, Complete" as the format</li>
                <li>Save as <strong>${workflowName || 'workflow'}_documentation.html</strong></li>
              </ol>
              <p>Or use the keyboard shortcut:</p>
              <ul>
                <li>Windows/Linux: Press <kbd>Ctrl</kbd> + <kbd>S</kbd></li>
                <li>Mac: Press <kbd>Cmd</kbd> + <kbd>S</kbd></li>
              </ul>
            </div>
          </body>
          </html>
        `);
        win.document.close();
      }
    }

    // Add event listeners for download buttons
    document.getElementById('downloadSvgBtn').addEventListener('click', downloadDiagram);
    document.getElementById('downloadHtmlBtn').addEventListener('click', () => {
      downloadAsHTML().catch(error => {
        console.error('Error in downloadAsHTML:', error);
        showMessage('Failed to generate HTML. Please try again.', 'error');
      });
    });

    // Add SVG download functionality
    async function downloadDiagram() {
      // Target the SVG inside the graph container specifically
      const svgElement = document.querySelector('#graph svg');
      if (!svgElement) {
        showMessage('No diagram content found to download. Please load a workflow first.', 'error');
        return;
      }

      try {
        // Create a temporary container to hold the SVG
        const container = document.createElement('div');
        container.style.position = 'fixed';
        container.style.top = '-9999px';
        container.style.background = 'white';
        container.style.padding = '20px';
        
        // Clone the SVG and its parent to maintain styles
        const svgClone = svgElement.cloneNode(true);
        
        // Ensure the cloned SVG has proper dimensions
        const bbox = svgElement.getBBox();
        svgClone.setAttribute('width', bbox.width);
        svgClone.setAttribute('height', bbox.height);
        svgClone.setAttribute('viewBox', `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);
        
        container.appendChild(svgClone);
        document.body.appendChild(container);

        // Function to convert images to data URLs
        async function convertImagesToDataUrls(element) {
          const images = element.querySelectorAll('image, img');
          const promises = [];
          
          for (const img of images) {
            const src = img.getAttribute('xlink:href') || img.src;
            if (!src) continue;
            
            const promise = new Promise((resolve) => {
              const imgEl = new Image();
              imgEl.crossOrigin = 'Anonymous';
              imgEl.onload = () => {
                try {
                  const canvas = document.createElement('canvas');
                  canvas.width = imgEl.width || 24;
                  canvas.height = imgEl.height || 24;
                  const ctx = canvas.getContext('2d');
                  ctx.drawImage(imgEl, 0, 0);
                  const dataUrl = canvas.toDataURL('image/png');
                  if (img.tagName.toLowerCase() === 'image') {
                    img.setAttribute('xlink:href', dataUrl);
                  } else {
                    img.src = dataUrl;
                  }
                } catch (e) {
                  console.error('Error converting image:', e);
                }
                resolve();
              };
              imgEl.onerror = () => {
                console.warn('Failed to load image:', src);
                resolve();
              };
              imgEl.src = src;
            });
            
            promises.push(promise);
          }
          
          return Promise.all(promises);
        }

        // Convert all images to data URLs
        await convertImagesToDataUrls(svgClone);

        // Use html2canvas to convert SVG to canvas
        const canvas = await html2canvas(container, {
          scale: 2,
          useCORS: true,
          logging: true,
          allowTaint: true,
          backgroundColor: 'white',
          onclone: (clonedDoc) => {
            // Ensure the SVG is visible and properly sized
            const clonedSvg = clonedDoc.querySelector('svg');
            if (clonedSvg) {
              clonedSvg.style.display = 'block';
              clonedSvg.style.overflow = 'visible';
            }
            
            // Ensure all foreignObject content is visible
            const foreignObjects = clonedDoc.querySelectorAll('foreignObject');
            foreignObjects.forEach(fo => {
              fo.style.overflow = 'visible';
              const content = fo.querySelector('div');
              if (content) {
                content.style.display = 'block';
                content.style.overflow = 'visible';
              }
            });
          }
        });

        // Convert canvas to PNG
        const pngData = canvas.toDataURL('image/png');
        
        // Create download link
        const link = document.createElement('a');
        link.href = pngData;
        link.download = `${workflowName}.png`;
        
        // Add link to body and trigger click
        document.body.appendChild(link);
        link.click();
        
        // Clean up
        document.body.removeChild(link);
        document.body.removeChild(container);
        
      } catch (error) {
        console.error('Error creating diagram:', error);
        showMessage('Error creating diagram image. Please try again.', 'error');
      }
    }

    // Add event listener for diagram download button
    document.getElementById('downloadSvgBtn').addEventListener('click', downloadDiagram);

    // Zoom controls logic
    let currentZoom = 1.0;
    const minZoom = 0.2;
    const maxZoom = 3.0;
    const zoomStep = 0.1;
    document.getElementById('zoomInBtn').addEventListener('click', function() {
      const svg = document.querySelector('#graph svg');
      if (currentZoom < maxZoom && svg) {
        currentZoom += zoomStep;
        svg.style.transform = `scale(${currentZoom})`;
        svg.style.transformOrigin = 'top left';
      }
    });
    document.getElementById('zoomOutBtn').addEventListener('click', function() {
      const svg = document.querySelector('#graph svg');
      if (currentZoom > minZoom && svg) {
        currentZoom -= zoomStep;
        svg.style.transform = `scale(${currentZoom})`;
        svg.style.transformOrigin = 'top left';
      }
    });

    function createSwitchArrows(workflowItems, positions) {
      let arrows = '';

      // Find all switch nodes
      const switchNodes = workflowItems.filter(item => item.getAttribute('type') === 'switch');
      
      switchNodes.forEach(switchNode => {
        const switchName = switchNode.getAttribute('name');
        const conditions = switchNode.querySelectorAll('condition');
        
        // Get the default target if specified in the switch node's out-name attribute
        const defaultTarget = switchNode.getAttribute('out-name');
        
        // Process all conditions
        conditions.forEach(condition => {
          const targetName = condition.getAttribute('label');
          if (positions[switchName] && positions[targetName]) {
            const from = positions[switchName];
            const to = positions[targetName];
            
            // Create arrow from switch to target
            const path = createArrowPath(
              from.x + from.width / 2,
              from.y + from.height / 2,
              to.x + to.width / 2,
              to.y + to.height / 2
            );
            
            arrows += `<path d="${path}" stroke="#0079ad" stroke-width="1.5" fill="none" marker-end="url(#arrow)" />`;
          }
        });
        
        // Handle default case if it exists and points to a valid target
        if (defaultTarget && defaultTarget !== 'null' && positions[switchName] && positions[defaultTarget]) {
          const from = positions[switchName];
          const to = positions[defaultTarget];
          
          // Create arrow from switch to default target
          const path = createArrowPath(
            from.x + from.width / 2,
            from.y + from.height / 2,
            to.x + to.width / 2,
            to.y + to.height / 2
          );
          
          // Use green color for the default case
          arrows += `<path d="${path}" stroke="#4CAF50" stroke-width="1.5" fill="none" marker-end="url(#arrow)" />`;
        }
      });

      return arrows;
    }
    console.log('Invoking createSwitchArrows with workflowItems and positions:', workflowItems, positions); // Debugging log
    const switchArrows = createSwitchArrows(workflowItems, positions);
    console.log('Generated switch arrows:', switchArrows); // Debugging log
  </script>
  
  <footer style="font-family: 'Metropolis', Arial, sans-serif; text-align: center; padding: 1rem; margin-top: 2rem; font-size: 0.8rem; color: #666; border-top: 1px solid #eee;">
    <p>VMware VCF Operations Orchestrator™ is a trademark of Broadcom Inc. This tool is not affiliated with or endorsed by Broadcom Inc. or its subsidiaries.</p>
  </footer>
</body>
</html>